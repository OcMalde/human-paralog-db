<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>__GENE1__ (__ACC1__) vs __GENE2__ (__ACC2__) – __PAIR__</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="stylesheet" href="__MOLSTAR_CSS__"/>
<style>
  :root{ --bg:#fafafa; --pane:#fff; --muted:#888; --soft:#f3f3f3; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:18px 24px;background:#fff9f0;border-bottom:1px solid #efe2c3;box-shadow:0 1px 4px rgba(0,0,0,.04)}
  header .title-main{margin:0;font-size:24px;font-weight:700;color:#2f2514}
  header .title-sub{margin-top:4px;font-size:13px;color:#7a6842;letter-spacing:0.08em;text-transform:uppercase}
  #wrap{padding:12px;display:grid;gap:12px;max-width:1400px;margin:0 auto}
  .card{background:var(--pane);border:1px solid #e8e8e8;border-radius:10px;box-shadow:0 1px 1px rgba(0,0,0,.03)}
  .card h2{font-size:15px;margin:0;padding:10px 12px;border-bottom:1px solid #eee}
  .card .body{padding:12px}
  .card .card-header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-bottom:1px solid #eee;gap:12px;flex-wrap:wrap}
  .card.collapsible h2{margin:0;padding:0;border-bottom:none;font-size:15px}
  .collapse-toggle{background:#f5f1e6;border:1px solid #e0d7c2;color:#5f4d2f;border-radius:999px;font-size:11px;padding:4px 12px;cursor:pointer}
  .collapse-toggle:hover{background:#ebe2cf}
  .card.collapsible .body.collapsed{display:none}
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
  select,button{font-size:13px;padding:6px 8px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer}
  button:hover{background:#f0f0f0}
  .note{font-size:12px;color:#555}
  #viewer{height:520px; position:relative; z-index:0; overflow:hidden; border-radius:8px; border:1px solid #e6e6e6;}
  #viewer .msp-plugin{position:absolute; inset:0;}
  .legend-dot{display:inline-block;width:10px;height:10px;border-radius:50%;margin-right:6px;border:1px solid #888}
  .green{background:#43a047}
  .orange{background:#fb8c00}

  #seqwrap{padding:4px 2px}
  .mgr{width:100%}
  .rtab{width:100%;border-collapse:collapse}
  .rtab td{vertical-align:middle;padding:2px 6px}
  .rtab td:first-child{width:150px}
  .rowlbl{
    white-space:nowrap;
    font-size:12px;
    color:#444;
    background:#f6fafe;
    border-right:1px solid #eef;
    padding:4px 6px;
    min-width:140px;
  }

  .am-main-row{
    border-top:2px solid #c3ceff;
    border-bottom:2px solid #c3ceff;
  }
  .am-main-label{
    font-weight:600;
    background:#e9f0ff;
  }

  table{width:100%;border-collapse:collapse}
  th,td{font-size:13px;border-top:1px solid #eee;padding:6px 8px;text-align:left}
  th{background:var(--soft)}
  .clickable{cursor:pointer}
  .clickable:hover{background:#f0f8ff}
  .small{font-size:12px;color:#666}
  .selected{background-color:#fff8e1!important}

  .am-matrix-toggle{
    font-size:11px;
    padding:0 6px;
    margin-left:4px;
    border-radius:6px;
  }

/* ========== SUMMARY SECTION STYLES ========== */
.summary-section{background:#ffffff;border:1px solid #ebe4d7;border-radius:14px;padding:22px;box-shadow:0 15px 35px rgba(51,41,16,0.06);color:#1f1b16;margin-bottom:16px}
.summary-section h2{color:#1f1b16;border-bottom:1px solid #f2ece0;padding-bottom:12px;margin-bottom:18px;font-size:18px}
.summary-grid{display:grid;grid-template-columns:1fr 1fr;gap:18px}
@media(max-width:900px){.summary-grid{grid-template-columns:1fr}}
.protein-card{background:#fdf9f1;border-radius:12px;padding:16px;border:1px solid #f2ead8}
.protein-card h3{margin:0 0 8px;font-size:16px;display:flex;align-items:center;gap:10px;color:#2c210e}
.protein-card .gene-symbol{font-size:21px;font-weight:700}
.essential-badge{background:#c62828;color:#fff;font-size:11px;padding:3px 8px;border-radius:999px;font-weight:600}
.not-essential-badge{background:#ede4cf;color:#6d5830;font-size:11px;padding:3px 8px;border-radius:999px}
.protein-links{display:flex;gap:10px;margin:10px 0}
.protein-links a{color:#735c29;text-decoration:none;background:#fff;border:1px solid #f0e4c8;padding:4px 12px;border-radius:999px;font-size:12px;transition:background 0.15s}
.protein-links a:hover{background:#f5ecdb}
.chr-info{font-size:12px;color:#6b5c40;margin-top:6px}
.pair-meta{background:#fff;border:1px dashed #e4dac4;border-radius:12px;padding:14px;margin-top:18px}
.pair-meta-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px}
.meta-item{text-align:center}
.meta-item .value{font-size:20px;font-weight:700;color:#2f2614}
.meta-item .label{font-size:11px;color:#7d6d4f;text-transform:uppercase;letter-spacing:0.05em}
 .ppi-highlights{margin-top:22px;background:#fffdfa;border-radius:12px;padding:16px;border:1px solid #f4ead4}
 .ppi-header{display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap}
 .ppi-header h3{margin:0;font-size:15px;color:#3a2f1b}
 .ppi-toggle{display:flex;align-items:center;gap:6px;font-size:12px;color:#776550}
 .ppi-toggle input{margin:0}
 .ppi-lists{display:grid;grid-template-columns:1fr 1fr;gap:18px;margin-top:12px}
 @media(max-width:900px){.ppi-lists{grid-template-columns:1fr}}
 .ppi-label{font-size:11px;font-weight:700;color:#5d4c2f;letter-spacing:0.06em;text-transform:uppercase;margin-bottom:6px}
 .ppi-chip-list{display:flex;flex-wrap:wrap;gap:6px}
 .ppi-chip{padding:4px 12px;border-radius:999px;background:#fff3d8;border:1px solid #f0d6ac;font-size:12px;font-weight:600;color:#5a3300}
 .ppi-chip.empty{background:#f8f0e1;border-style:dashed;color:#9c8561}
 .ppi-note{font-size:11px;color:#8d7a57;margin-top:4px}
 .ppi-graph-wrapper{margin-top:18px;padding:12px;border:1px dashed #efd8af;border-radius:12px;background:#fffdf5}
 #ppiNetwork{width:100%;height:230px;display:block}
 #ppiNetwork text{font-size:11px;fill:#3a3225}
 #ppiNetwork .gene-node circle{fill:#5c4433;stroke:#f9f6ef;stroke-width:2}
 #ppiNetwork .shared-node circle{fill:#e1c499;stroke:#b68b4c}
 #ppiNetwork .unique-node circle{fill:#fff;stroke:#c69e61;stroke-width:1.5;stroke-dasharray:3 2}
 #ppiNetwork line{stroke:#d1c2aa;stroke-width:1.8}
 #ppiNetwork .non-shared{stroke-dasharray:4 3;opacity:0.7}
 .ppi-graph-note{font-size:11px;color:#8b7a60;margin-top:8px}
.conservation-viz{margin-top:22px;background:#fff;border-radius:12px;padding:16px;border:1px solid #f1ecdf;color:#2a2620}
.conservation-viz h3{margin:0 0 12px;font-size:16px;color:#2a2620}
.radar-boxplot-container{display:grid;grid-template-columns:340px 1fr;gap:18px;min-height:280px}
@media(max-width:800px){.radar-boxplot-container{grid-template-columns:1fr}}
.radar-plot{width:100%;height:280px;position:relative;display:flex;align-items:center;justify-content:center;background:#fff;border:1px solid #f0e7d3;border-radius:10px}
.radar-plot canvas{width:100%;height:100%}
.radar-plot svg{width:100%;height:100%}
.radar-fallback-note{font-size:11px;color:#7a6f55;text-align:center;margin-top:6px}
#radarChart{width:340px;height:280px}
.boxplot-panel{background:#f9f6ef;border-radius:10px;padding:15px;border:1px solid #ece4d2;display:flex;flex-direction:column}
.boxplot-panel h4{margin:0;font-size:14px;color:#5c4d30}
.boxplot-header{display:flex;align-items:center;justify-content:space-between;gap:10px;margin-bottom:8px;flex-wrap:wrap}
.reset-metric-btn{background:#f5f1e6;border:1px solid #e0d7c2;color:#5f4d2f;border-radius:999px;font-size:11px;padding:4px 10px;cursor:pointer;transition:background 0.15s}
.reset-metric-btn:hover{background:#ede4cf}
#boxplotContainer{flex:1;min-height:180px}
.boxplot-hint{font-size:12px;color:#7a6f55;text-align:center;padding:18px}
.metric-details{margin-top:10px;padding:12px;background:#fff;border-radius:8px;font-size:13px;border:1px solid #f0e7d3}
.metric-details .stat-row{display:flex;justify-content:space-between;padding:4px 0;border-bottom:1px solid #efe5cf}
.metric-details .stat-row:last-child{border-bottom:none}
.percentile-bar{height:8px;background:#f0f0f0;border-radius:4px;margin-top:6px;overflow:hidden}
.percentile-fill{height:100%;background:linear-gradient(90deg,#c39b63,#806845);border-radius:4px;transition:width 0.3s ease}
.cons-high{color:#2e7d32}.cons-medium{color:#ef6c00}.cons-low{color:#c62828}
.conservation-list{margin-top:16px;border-top:1px dashed #e5dcc8;padding-top:12px;display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:12px}
.conservation-list .metric{background:#fdfaf4;border:1px solid #f1e6d2;border-radius:10px;padding:10px;cursor:pointer;transition:border-color 0.2s,box-shadow 0.2s}
.conservation-list .label{display:block;font-weight:600;color:#352a18;margin-bottom:4px}
.conservation-list .value{font-size:18px;font-weight:700;color:#2f2614}
.conservation-list .percentile{display:block;font-size:12px;margin-top:4px}
.conservation-list .metric.active{border-color:#d3a552;box-shadow:0 0 0 2px rgba(211,165,82,0.18)}
.conservation-list .metric:focus-visible{outline:2px solid #d3a552}
/* PDBe viewer */
  #pdbeViewer{
    height:420px;
    position:relative;
    z-index:0;
    overflow:hidden;
    border-radius:8px;
    border:1px solid #e6e6e6;
    margin-top:8px;
    background:#1a1a1a;
  }
  #pdbeViewer .msp-plugin{
    position:absolute;
    inset:0;
  }
  
  .pdbe-controls{
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
    margin-bottom:8px;
  }
  
  .pdbe-info-box{
    background:#f8f9fa;
    border:1px solid #e0e0e0;
    border-radius:6px;
    padding:8px 12px;
    margin-top:8px;
    font-size:12px;
  }
  
  .pdbe-info-box .label{
    font-weight:600;
    color:#333;
  }
  
  .pdbe-ligand-list{
    margin-top:4px;
    color:#555;
  }
  
  .display-legend{
    font-size:11px;
    margin-top:4px;
    padding:6px 10px;
    background:#f0f7ff;
    border-radius:4px;
    border-left:3px solid #4a90d9;
  }
  
  .btn-active{
    background:#e3f2fd !important;
    border-color:#1976d2 !important;
  }
</style>
</head>
<body>
<header>
  <div class="title-main">__GENE1__ &#8596; __GENE2__</div>
  <div class="title-sub">Paralog pair __PAIR__ &middot; Generated __GENERATED__</div>
</header>

<div id="wrap">

  <!-- ========== SUMMARY SECTION ========== -->
  <section class="card summary-section">
    <h2>Pair Summary – Quick Overview</h2>
    <div class="summary-grid">
      <div class="protein-card">
        <h3><span class="gene-symbol">__GENE1__</span><span id="sum-essential1" class="not-essential-badge">Not Essential</span></h3>
        <div class="protein-links">
          <a href="https://www.uniprot.org/uniprotkb/__ACC1__" target="_blank">UniProt</a>
          <a href="https://www.ebi.ac.uk/pdbe/pdbe-kb/proteins/__ACC1__" target="_blank">PDBe-KB</a>
        </div>
        <div class="chr-info"><strong>UniProt:</strong> __ACC1__<br><span id="chr-loc1">Loading chromosome info...</span></div>
      </div>
      <div class="protein-card">
        <h3><span class="gene-symbol">__GENE2__</span><span id="sum-essential2" class="not-essential-badge">Not Essential</span></h3>
        <div class="protein-links">
          <a href="https://www.uniprot.org/uniprotkb/__ACC2__" target="_blank">UniProt</a>
          <a href="https://www.ebi.ac.uk/pdbe/pdbe-kb/proteins/__ACC2__" target="_blank">PDBe-KB</a>
        </div>
        <div class="chr-info"><strong>UniProt:</strong> __ACC2__<br><span id="chr-loc2">Loading chromosome info...</span></div>
      </div>
    </div>
    <div class="pair-meta">
      <div class="pair-meta-grid">
        <div class="meta-item"><div class="value" id="sum-wgd">–</div><div class="label">WGD Origin</div></div>
        <div class="meta-item"><div class="value" id="sum-family-size">–</div><div class="label">Family Size</div></div>
        <div class="meta-item"><div class="value" id="sum-closest">–</div><div class="label">Closest Pair</div></div>
        <div class="meta-item"><div class="value" id="sum-same-chr">–</div><div class="label">Same Chr</div></div>
        <div class="meta-item"><div class="value" id="sum-interact">–</div><div class="label">Interact (BioPlex)</div></div>
        <div class="meta-item"><div class="value" id="sum-shared-ppi">–</div><div class="label">Shared PPIs</div></div>
      </div>
    </div>
<div class="ppi-highlights">
  <div class="ppi-header">
    <div>
      <h3>Shared Protein Partners</h3>
      <p class="small">Based on BioPlex interactors captured for this paralog pair.</p>
    </div>
    <label class="ppi-toggle">
      <input type="checkbox" id="toggleNonShared" checked/>
      <span>Show unique-only partners</span>
    </label>
  </div>
  <div class="ppi-lists">
    <div>
      <div class="ppi-label">Shared PPIs</div>
      <div id="sharedPpiList" class="ppi-chip-list"><span class="ppi-chip empty">Loading shared partners…</span></div>
      <div id="sharedPpiNote" class="ppi-note"></div>
    </div>
    <div id="nonSharedLists" class="ppi-nonshared">
      <div>
        <div class="ppi-label"><span id="ppiLabelA">__GENE1__</span> unique partners</div>
        <div id="uniquePpiA" class="ppi-chip-list"><span class="ppi-chip empty">Loading…</span></div>
        <div id="uniquePpiANote" class="ppi-note"></div>
      </div>
      <div>
        <div class="ppi-label"><span id="ppiLabelB">__GENE2__</span> unique partners</div>
        <div id="uniquePpiB" class="ppi-chip-list"><span class="ppi-chip empty">Loading…</span></div>
        <div id="uniquePpiBNote" class="ppi-note"></div>
      </div>
    </div>
  </div>
  <div class="ppi-graph-wrapper">
    <svg id="ppiNetwork" role="img" aria-label="Mini PPI network" viewBox="0 0 420 240"></svg>
    <div class="ppi-graph-note" id="ppiGraphNote"></div>
  </div>
</div>
    <div class="conservation-viz">
      <h3>Conservation Compared to ~100k Human Paralog Pairs</h3>
      <p class="small" style="color:#666;margin-bottom:15px;">Click on any metric point in the radar chart to see the detailed distribution. Higher percentile = more conserved relative to other pairs.</p>
      <div class="radar-boxplot-container">
        <div class="radar-plot" id="radarChartWrapper">
          <canvas id="radarChart"></canvas>
        </div>
        <div class="boxplot-panel">
          <div class="boxplot-header">
            <h4 id="boxplotTitle">Select a Metric</h4>
            <button type="button" class="reset-metric-btn" id="resetMetricView" title="Clear selection and show the overview again">Back to overview</button>
          </div>
          <div id="boxplotContainer"><div class="boxplot-hint">Click a radar point or any metric card to compare this pair with the cohort</div></div>
          <div class="metric-details" id="metricDetails" style="display:none;">
            <div class="stat-row"><span>This pair's value:</span><strong id="detail-value">–</strong></div>
            <div class="stat-row"><span>Percentile:</span><strong id="detail-percentile">–</strong></div>
            <div class="stat-row"><span>Interpretation:</span><span id="detail-interp">–</span></div>
            <div class="stat-row"><span>Metric direction:</span><span id="detail-direction">–</span></div>
            <div class="percentile-bar"><div class="percentile-fill" id="percentile-fill" style="width:50%"></div></div>
          </div>
        </div>
      </div>
      <div id="conservationList" class="conservation-list"></div>
    </div>
  </section>
  <!-- ========== END SUMMARY SECTION ========== -->

  <!-- Structure card -->
  <section class="card">
    <h2>
      <span id="contextTitle">Full: __GENE1__ × __GENE2__</span>
      <span class="small" style="margin-left:10px">
        <span class="legend-dot green"></span>__GENE1__ &nbsp;&nbsp;
        <span class="legend-dot orange"></span>__GENE2__
      </span>
    </h2>
    <div class="body">
      <div class="row">
        <label>Color by:
          <select id="colorBy">
            <option value="uniform">Uniform</option>
            <option value="plddt">pLDDT (confidence)</option>
            <option value="am">AlphaMissense</option>
            <option value="dam">Δ AlphaMissense</option>
            <option value="aligned">Aligned vs Gap</option>
            <option value="domains">Domains</option>
            <option value="ss">2D Structure (α/β)</option>
            <option value="cavities">Cavities</option>
            <option value="drugclip">DrugCLIP</option>
            <option value="plma">PLMA Categories</option>
          </select>
        </label>
        <button id="center">Center</button>
        <button id="backFull">Back to full</button>
        <button id="lockViewer" title="Lock hover to keep chain B highlights visible">Lock Hover</button>
        <span class="note">TM-score: <b id="tmScore">__TM__</b> · columns: __ALNLEN__</span>
      </div>
      <div id="viewer"></div>
    </div>
  </section>

  <!-- PDBe complexes card -->
  <section class="card collapsible" id="pdbeCard">
    <div class="card-header">
      <h2>Experimental Structures &amp; Complexes (PDBe-KB)</h2>
      <button class="collapse-toggle" id="pdbeCollapseBtn" aria-expanded="true" aria-controls="pdbeCardBody">Collapse section</button>
    </div>
    <div class="body" id="pdbeCardBody">
      <div class="pdbe-controls">
        <label>Structure:
          <select id="pdbeStructSelect">
            <option value="">Loading...</option>
          </select>
        </label>
        <button id="pdbeHighlightProtein">Highlight Protein</button>
        <button id="pdbeHighlightLigands">Highlight Ligands</button>
        <button id="pdbeClearHighlight">Clear</button>
        <button id="pdbeSyncCamera" title="Sync orientation with main viewer">Sync Orientation</button>
        <button id="pdbeCenter">Center</button>
      </div>
      <div class="display-legend" id="pdbeLegend">
        Complex shown in <strong>grey</strong>. Click buttons to highlight protein of interest (<span style="color:#43a047">green</span>) or ligands (<span style="color:#e91e63">pink</span>).
      </div>
      <div id="pdbeViewer"></div>
      <div class="pdbe-info-box" id="pdbeInfoBox">
        <div><span class="label">PDB ID:</span> <span id="pdbePdbId">-</span></div>
        <div><span class="label">Source UniProt:</span> <span id="pdbeSourceAcc">-</span></div>
        <div><span class="label">Chains of interest:</span> <span id="pdbeChains">-</span></div>
        <div><span class="label">Coverage:</span> <span id="pdbeCoverage">-</span></div>
        <div><span class="label">Resolution:</span> <span id="pdbeResolution">-</span></div>
        <div class="pdbe-ligand-list"><span class="label">Ligands:</span> <span id="pdbeLigands">-</span></div>
      </div>
    </div>
  </section>

  <!-- Sequence / domains card -->
  <section class="card">
    <h2>Alignment-axis sequences, domains &amp; secondary structure</h2>
    <div class="body">
      <div class="row" id="amModeRow">
        <label>AM scale:
          <select id="amMode"></select>
        </label>
        <span class="small">Normalize AlphaMissense per protein for comparison.</span>
      </div>
      <div id="seqwrap">
        <nightingale-manager id="mgr" class="mgr"></nightingale-manager>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Domains (filtered)</h2>
    <div class="body" style="display:grid;gap:12px;grid-template-columns:1fr 1fr">
      <div>
        <table id="domA">
          <thead>
            <tr>
              <th>Sel</th>
              <th>__GENE1__ (__ACC1__) domain</th>
              <th>range</th>
              <th>cavity / drug</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div>
        <table id="domB">
          <thead>
            <tr>
              <th>Sel</th>
              <th>__GENE2__ (__ACC2__) domain</th>
              <th>range</th>
              <th>cavity / drug</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Domain × Domain sub-alignments (Foldseek)</h2>
    <div class="body">
      <table id="domPairs"><thead><tr><th>__GENE1__ domain</th><th>__GENE2__ domain</th><th>fident</th><th>TM</th><th>ΔAM%</th></tr></thead><tbody></tbody></table>
      <div class="small">Click a row to load the sub-alignment into the viewer. Use "Back to full" to restore the full A/B.</div>
    </div>
  </section>

</div>

<!-- Chart.js for Radar Chart and Boxplot -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<link rel="stylesheet" href="__MOLSTAR_CSS__"/>
<script src="__MOLSTAR_JS__"></script>
<script type="importmap">
{"imports":{"@nightingale-elements/":"__NITE_CDN__"}}
</script>
<script type="module">
import "@nightingale-elements/nightingale-manager@latest";
import "@nightingale-elements/nightingale-navigation@latest";
import "@nightingale-elements/nightingale-sequence@latest";
import "@nightingale-elements/nightingale-track@latest";
</script>

<script>
/* ----------------- Data from Python ----------------- */
const DATA = __DATA__;
const PDB64_FULL = "__PDB64__";
const SUMMARY = __SUMMARY_DATA__;

const AA_ORDER = ['K','R','H','E','D','N','Q','T','S','C','G','A','V','L','I','M','P','Y','F','W'];
const AM_MODES = DATA.amModes || ['raw'];
const MAX_SHARED_LIST = 18;
const MAX_UNIQUE_LIST = 12;
const MAX_SHARED_GRAPH = 7;
const MAX_UNIQUE_GRAPH = 4;

let amMode = 'raw';
let amTrackA = null;
let amTrackB = null;
let damTrack = null;
let amMatrixTracksA = [];
let amMatrixTracksB = [];

/* ----------------- PDBe complexes data ----------------- */
const PDBe_COMPLEXES = DATA.pdbeComplexes || [];
const UNIPROT_A = DATA.a1 || '';
const UNIPROT_B = DATA.a2 || '';

/* ========== SUMMARY SECTION FUNCTIONS ========== */
let radarChart = null;
let boxplotChart = null;
let activeMetricKey = null;
let PPI_GRAPH_DATA = null;
let showUniquePpis = true;
const DEFAULT_BOXPLOT_HINT = 'Click a radar point or metric card to compare this pair with the cohort';

function initSummarySection() {
  const pair = SUMMARY.pair || {};
  const gene1 = SUMMARY.gene1 || {};
  const gene2 = SUMMARY.gene2 || {};
  
  if (gene1.is_essential) {
    document.getElementById('sum-essential1').textContent = 'Essential (DepMap)';
    document.getElementById('sum-essential1').className = 'essential-badge';
  }
  if (gene2.is_essential) {
    document.getElementById('sum-essential2').textContent = 'Essential (DepMap)';
    document.getElementById('sum-essential2').className = 'essential-badge';
  }
  
  if (gene1.chromosome && gene1.chromosome.chromosome && gene1.chromosome.chromosome !== 'NA') {
    const chr1 = gene1.chromosome;
    document.getElementById('chr-loc1').innerHTML = `<strong>Chr:</strong> ${chr1.chromosome} : ${Number(chr1.start).toLocaleString()} - ${Number(chr1.end).toLocaleString()}`;
  } else {
    document.getElementById('chr-loc1').textContent = 'Chromosome info not available';
  }
  
  if (gene2.chromosome && gene2.chromosome.chromosome && gene2.chromosome.chromosome !== 'NA') {
    const chr2 = gene2.chromosome;
    document.getElementById('chr-loc2').innerHTML = `<strong>Chr:</strong> ${chr2.chromosome} : ${Number(chr2.start).toLocaleString()} - ${Number(chr2.end).toLocaleString()}`;
  } else {
    document.getElementById('chr-loc2').textContent = 'Chromosome info not available';
  }
  
  const boolToStr = (v) => v === true ? 'Yes' : (v === false ? 'No' : '–');
  document.getElementById('sum-wgd').textContent = boolToStr(pair.wgd);
  document.getElementById('sum-family-size').textContent = (pair.family_size ?? '–');
  document.getElementById('sum-closest').textContent = boolToStr(pair.closest);
  document.getElementById('sum-same-chr').textContent = boolToStr(pair.same_chr);
  document.getElementById('sum-interact').textContent = boolToStr(pair.interact_bioplex);
  document.getElementById('sum-shared-ppi').textContent = (pair.n_shared_ppi ?? '0');
  
  renderPpiSection(pair, gene1, gene2);
  initRadarChart();
  renderConservationList();
  resetMetricSelection();

  const resetBtn = document.getElementById('resetMetricView');
  if (resetBtn && !resetBtn.dataset.bound) {
    resetBtn.addEventListener('click', () => resetMetricSelection(), { passive: true });
    resetBtn.dataset.bound = '1';
  }
}

function initRadarChart() {
  const conservation = SUMMARY.conservation || {};
  const wrapper = document.getElementById('radarChartWrapper');
  if (!wrapper) return false;

  const labels = [];
  const radarValues = [];
  const metricKeys = [];
  
  for (const [key, info] of Object.entries(conservation)) {
    labels.push(info.label || key);
    radarValues.push(typeof info.radar_value === "number" ? info.radar_value : 50);
    metricKeys.push(key);
  }
  
  if (labels.length === 0) {
    wrapper.innerHTML = '<div class="boxplot-hint">Conservation data not available</div>';
    return false;
  }

  if (typeof Chart === 'undefined') {
    renderStaticRadar(wrapper, labels, radarValues);
    radarChart = null;
    return false;
  }

  const canvas = ensureRadarCanvas(wrapper);
  const ctx = canvas.getContext('2d');
  if (radarChart) {
    radarChart.destroy();
    radarChart = null;
  }
  
  radarChart = new Chart(ctx, {
    type: 'radar',
    data: {
      labels: labels,
      datasets: [{
        label: 'Conservation Percentile',
        data: radarValues,
        fill: true,
        backgroundColor: 'rgba(102, 126, 234, 0.2)',
        borderColor: 'rgba(102, 126, 234, 1)',
        pointBackgroundColor: 'rgba(102, 126, 234, 1)',
        pointBorderColor: '#fff',
        pointHoverBackgroundColor: '#fff',
        pointHoverBorderColor: 'rgba(102, 126, 234, 1)',
        pointRadius: 6,
        pointHoverRadius: 8,
      }]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        r: {
          angleLines: { display: true },
          suggestedMin: 0,
          suggestedMax: 100,
          ticks: { stepSize: 25, callback: (v) => v + '%' }
        }
      },
      plugins: {
        legend: { display: false },
        tooltip: { callbacks: { label: (ctx) => (((ctx.parsed && ctx.parsed.r) ?? 0).toFixed(1) + '% percentile') } }
      },
      onClick: (event, elements) => {
        if (elements.length > 0) {
          const idx = elements[0].index;
          showBoxplotForMetric(metricKeys[idx]);
        }
      }
    }
  });
  return true;
}

function ensureRadarCanvas(wrapper){
  let canvas = wrapper.querySelector('canvas#radarChart');
  if (!canvas) {
    canvas = document.createElement('canvas');
    canvas.id = 'radarChart';
    wrapper.innerHTML = '';
    wrapper.appendChild(canvas);
  }
  return canvas;
}

function renderStaticRadar(wrapper, labels, values){
  const size = 320;
  const center = size / 2;
  const radius = Math.min(center - 20, 130);
  const rings = 4;
  wrapper.innerHTML = '';

  const svgNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS(svgNS, 'svg');
  svg.setAttribute('viewBox', `0 0 ${size} ${size}`);

  const angleStep = (Math.PI * 2) / labels.length;
  const toPoint = (val, idx) => {
    const angle = -Math.PI / 2 + idx * angleStep;
    const r = (Math.max(0, Math.min(100, val)) / 100) * radius;
    return {
      x: center + r * Math.cos(angle),
      y: center + r * Math.sin(angle)
    };
  };

  // rings
  for (let i = 1; i <= rings; i++){
    const r = (i / rings) * radius;
    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', center);
    circle.setAttribute('cy', center);
    circle.setAttribute('r', r);
    circle.setAttribute('fill', 'none');
    circle.setAttribute('stroke', '#f0e7d3');
    circle.setAttribute('stroke-width', '1');
    svg.appendChild(circle);
  }

  // axes + labels
  labels.forEach((label, idx) => {
    const angle = -Math.PI / 2 + idx * angleStep;
    const x = center + radius * Math.cos(angle);
    const y = center + radius * Math.sin(angle);

    const axis = document.createElementNS(svgNS, 'line');
    axis.setAttribute('x1', center);
    axis.setAttribute('y1', center);
    axis.setAttribute('x2', x);
    axis.setAttribute('y2', y);
    axis.setAttribute('stroke', '#e0d5bf');
    svg.appendChild(axis);

    const text = document.createElementNS(svgNS, 'text');
    text.setAttribute('x', center + (radius + 12) * Math.cos(angle));
    text.setAttribute('y', center + (radius + 12) * Math.sin(angle));
    text.setAttribute('text-anchor', Math.cos(angle) > 0.1 ? 'start' : (Math.cos(angle) < -0.1 ? 'end' : 'middle'));
    text.setAttribute('dominant-baseline', Math.sin(angle) > 0.1 ? 'hanging' : (Math.sin(angle) < -0.1 ? 'baseline' : 'middle'));
    text.setAttribute('font-size', '11px');
    text.setAttribute('fill', '#5c4d30');
    text.textContent = label;
    svg.appendChild(text);
  });

  // polygon
  const polygon = document.createElementNS(svgNS, 'polygon');
  const pts = values.map((val, idx) => {
    const pt = toPoint(val, idx);
    return `${pt.x},${pt.y}`;
  });
  polygon.setAttribute('points', pts.join(' '));
  polygon.setAttribute('fill', 'rgba(102,126,234,0.25)');
  polygon.setAttribute('stroke', 'rgba(102,126,234,0.9)');
  polygon.setAttribute('stroke-width', '2');
  svg.appendChild(polygon);

  wrapper.appendChild(svg);
  const note = document.createElement('div');
  note.className = 'radar-fallback-note';
  note.textContent = 'Static radar preview (Chart.js unavailable).';
  wrapper.appendChild(note);
}

function renderConservationList() {
  const container = document.getElementById('conservationList');
  if (!container) return;
  const conservation = SUMMARY.conservation || {};
  const entries = Object.entries(conservation);
  if (!entries.length) {
    container.innerHTML = '<div class="boxplot-hint">Conservation metrics unavailable.</div>';
    return;
  }

  container.innerHTML = '';
  entries.forEach(([metricKey, info]) => {
    const card = document.createElement('div');
    card.className = 'metric';
    card.dataset.metric = metricKey;
    card.setAttribute('role', 'button');
    card.tabIndex = 0;
    const directionTitle = info.direction_hint || (info.higher_is_more_conserved ? 'Higher values = more conserved' : 'Lower values = more conserved');
    card.title = directionTitle;

    const value = typeof info.value === 'number' ? info.value.toFixed(3) : '–';
    const pctVal = typeof info.percentile === 'number' ? info.percentile.toFixed(1) : null;
    const pctLabel = pctVal ? `${pctVal}% percentile` : 'Percentile unavailable';
    const badgeClass = pctVal === null ? '' : (info.percentile >= 75 ? 'cons-high' : (info.percentile >= 50 ? 'cons-medium' : 'cons-low'));

    card.innerHTML = `<span class="label">${info.label || ''}</span><span class="value">${value}</span><span class="percentile ${badgeClass}">${pctLabel}</span>`;
    card.addEventListener('click', () => showBoxplotForMetric(metricKey));
    card.addEventListener('keydown', (ev) => {
      if (ev.key === 'Enter' || ev.key === ' ') {
        ev.preventDefault();
        showBoxplotForMetric(metricKey);
      }
    });
    container.appendChild(card);
  });
  highlightMetricSelection();
}

function renderPpiSection(pair, gene1, gene2) {
  const info = pair?.ppi_network || {};
  const shared = Array.isArray(info.shared) ? info.shared : [];
  const uniqueA = Array.isArray(info.unique_gene1) ? info.unique_gene1 : [];
  const uniqueB = Array.isArray(info.unique_gene2) ? info.unique_gene2 : [];
  const geneAName = gene1.symbol || gene1.uniprot || 'Protein A';
  const geneBName = gene2.symbol || gene2.uniprot || 'Protein B';
  const toggle = document.getElementById('toggleNonShared');
  const nonSharedWrap = document.getElementById('nonSharedLists');
  const labelA = document.getElementById('ppiLabelA');
  const labelB = document.getElementById('ppiLabelB');
  if (labelA) labelA.textContent = geneAName;
  if (labelB) labelB.textContent = geneBName;

  populatePpiList('sharedPpiList', shared, MAX_SHARED_LIST, 'No shared interactors found', 'sharedPpiNote');
  populatePpiList('uniquePpiA', uniqueA, MAX_UNIQUE_LIST, `No unique partners for ${geneAName}`, 'uniquePpiANote');
  populatePpiList('uniquePpiB', uniqueB, MAX_UNIQUE_LIST, `No unique partners for ${geneBName}`, 'uniquePpiBNote');

  const hasUnique = uniqueA.length || uniqueB.length;
  if (toggle) {
    toggle.disabled = !hasUnique;
    if (!toggle.dataset.bound) {
      toggle.addEventListener('change', () => {
        showUniquePpis = !!toggle.checked;
        if (nonSharedWrap) nonSharedWrap.style.display = (showUniquePpis && hasUnique) ? '' : 'none';
        drawPpiGraph(PPI_GRAPH_DATA, showUniquePpis);
      }, { passive: true });
      toggle.dataset.bound = '1';
    }
    showUniquePpis = hasUnique ? true : false;
    toggle.checked = showUniquePpis;
  }
  if (nonSharedWrap) {
    nonSharedWrap.style.display = (hasUnique && showUniquePpis) ? '' : 'none';
  }

  if (!shared.length && !hasUnique) {
    const svg = document.getElementById('ppiNetwork');
    if (svg) svg.innerHTML = '';
    const note = document.getElementById('ppiGraphNote');
    if (note) note.textContent = 'PPI network unavailable for this pair.';
    PPI_GRAPH_DATA = null;
    return;
  }

  PPI_GRAPH_DATA = {
    gene1: geneAName,
    gene2: geneBName,
    shared,
    unique1: uniqueA,
    unique2: uniqueB
  };
  drawPpiGraph(PPI_GRAPH_DATA, showUniquePpis);
}

function populatePpiList(elementId, partners, limit, emptyMsg, noteId) {
  const el = document.getElementById(elementId);
  if (!el) return;
  const note = noteId ? document.getElementById(noteId) : null;
  if (!partners || !partners.length) {
    el.innerHTML = `<span class="ppi-chip empty">${emptyMsg}</span>`;
    if (note) note.textContent = '';
    return;
  }
  const shown = partners.slice(0, limit);
  el.innerHTML = shown.map((p) => {
    const label = escapeHtml(getPartnerLabel(p));
    const tooltip = escapeHtml(getPartnerTooltip(p));
    const attr = tooltip ? ` title="${tooltip}"` : '';
    return `<span class="ppi-chip"${attr}>${label}</span>`;
  }).join('');
  if (note) {
    const hidden = partners.length - shown.length;
    note.textContent = hidden > 0 ? `+${hidden} more` : '';
  }
}

function getPartnerLabel(entry) {
  if (!entry) return 'NA';
  if (typeof entry === 'string') return entry;
  return entry.display || entry.symbol || entry.name || entry.id || 'NA';
}

function getPartnerShortLabel(entry) {
  if (!entry) return 'NA';
  if (typeof entry === 'string') return entry;
  return entry.symbol || entry.display || entry.id || 'NA';
}

function getPartnerTooltip(entry) {
  if (!entry) return '';
  if (typeof entry === 'string') return entry;
  const bits = [];
  if (entry.symbol) bits.push(entry.symbol);
  if (entry.id) bits.push(`Entrez ${entry.id}`);
  return bits.join(' • ');
}

function escapeHtml(value) {
  if (value == null) return '';
  return String(value).replace(/[&<>"']/g, (ch) => ({
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
  }[ch]));
}

function drawPpiGraph(data, showUnique = true) {
  const svg = document.getElementById('ppiNetwork');
  const note = document.getElementById('ppiGraphNote');
  if (!svg) return;
  svg.innerHTML = '';
  if (!data) {
    if (note) note.textContent = 'PPI network unavailable for this pair.';
    return;
  }
  const width = 420;
  const height = 240;
  svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
  const centerY = height / 2;
  const svgNS = 'http://www.w3.org/2000/svg';

  const nodes = [];
  const lines = [];

  const gene1 = { key: 'gene1', label: data.gene1, x: 110, y: centerY, r: 22, className: 'gene-node', labelDy: 34 };
  const gene2 = { key: 'gene2', label: data.gene2, x: width - 110, y: centerY, r: 22, className: 'gene-node', labelDy: 34 };
  nodes.push(gene1, gene2);

  const sharedAll = Array.isArray(data.shared) ? data.shared : [];
  const shared = sharedAll.slice(0, MAX_SHARED_GRAPH);
  const sharedCount = shared.length;
  shared.forEach((partner, idx) => {
    const frac = sharedCount === 1 ? 0.5 : idx / (sharedCount - 1);
    const y = 50 + frac * (height - 100);
    const node = { key: `shared-${idx}`, label: getPartnerShortLabel(partner), x: width / 2, y, r: 14, className: 'shared-node', labelDy: 30 };
    nodes.push(node);
    lines.push({ from: gene1, to: node, className: 'shared-link' });
    lines.push({ from: gene2, to: node, className: 'shared-link' });
  });

  const unique1All = Array.isArray(data.unique1) ? data.unique1 : [];
  const unique2All = Array.isArray(data.unique2) ? data.unique2 : [];

  if (showUnique && unique1All.length) {
    unique1All.slice(0, MAX_UNIQUE_GRAPH).forEach((partner, idx) => {
      const y = 60 + idx * 38;
      const node = { key: `uniqA-${idx}`, label: getPartnerShortLabel(partner), x: 40, y, r: 11, className: 'unique-node', labelDx: -20, labelAlign: 'end', labelDy: 4 };
      nodes.push(node);
      lines.push({ from: gene1, to: node, className: 'non-shared' });
    });
  }
  if (showUnique && unique2All.length) {
    unique2All.slice(0, MAX_UNIQUE_GRAPH).forEach((partner, idx) => {
      const y = 60 + idx * 38;
      const node = { key: `uniqB-${idx}`, label: getPartnerShortLabel(partner), x: width - 40, y, r: 11, className: 'unique-node', labelDx: 20, labelAlign: 'start', labelDy: 4 };
      nodes.push(node);
      lines.push({ from: gene2, to: node, className: 'non-shared' });
    });
  }

  lines.forEach((ln) => {
    const el = document.createElementNS(svgNS, 'line');
    el.setAttribute('x1', ln.from.x);
    el.setAttribute('y1', ln.from.y);
    el.setAttribute('x2', ln.to.x);
    el.setAttribute('y2', ln.to.y);
    if (ln.className) el.setAttribute('class', ln.className);
    svg.appendChild(el);
  });

  nodes.forEach((node) => {
    const group = document.createElementNS(svgNS, 'g');
    group.setAttribute('class', `ppi-node ${node.className || ''}`.trim());
    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', node.x);
    circle.setAttribute('cy', node.y);
    circle.setAttribute('r', node.r);
    group.appendChild(circle);

    const label = document.createElementNS(svgNS, 'text');
    label.setAttribute('x', node.x + (node.labelDx || 0));
    const labelY = node.labelDy != null ? node.y + node.labelDy : node.y + node.r + 14;
    label.setAttribute('y', labelY);
    label.setAttribute('text-anchor', node.labelAlign || 'middle');
    label.textContent = node.label;
    group.appendChild(label);

    svg.appendChild(group);
  });

  if (note) {
    const notes = [];
    if (sharedAll.length > shared.length) {
      notes.push(`+${sharedAll.length - shared.length} shared partners hidden`);
    }
    if (showUnique) {
      if (unique1All.length > Math.min(unique1All.length, MAX_UNIQUE_GRAPH)) {
        notes.push(`+${unique1All.length - Math.min(unique1All.length, MAX_UNIQUE_GRAPH)} ${data.gene1} uniques hidden`);
      }
      if (unique2All.length > Math.min(unique2All.length, MAX_UNIQUE_GRAPH)) {
        notes.push(`+${unique2All.length - Math.min(unique2All.length, MAX_UNIQUE_GRAPH)} ${data.gene2} uniques hidden`);
      }
    } else if (unique1All.length || unique2All.length) {
      notes.push('Unique partners hidden (toggle to show).');
    }
    note.textContent = notes.join(' • ') || 'Shared nodes connect both paralogs; toggle to include unique-only partners.';
  }
}

function highlightMetricSelection() {
  const cards = document.querySelectorAll('#conservationList .metric');
  cards.forEach((card) => {
    const isActive = card.dataset.metric === activeMetricKey;
    card.classList.toggle('active', isActive);
    card.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });
}

function resetMetricSelection() {
  activeMetricKey = null;
  if (boxplotChart) {
    boxplotChart.destroy();
    boxplotChart = null;
  }
  const container = document.getElementById('boxplotContainer');
  if (container) {
    container.innerHTML = `<div class="boxplot-hint">${DEFAULT_BOXPLOT_HINT}</div>`;
  }
  const details = document.getElementById('metricDetails');
  if (details) {
    details.style.display = 'none';
  }
  const title = document.getElementById('boxplotTitle');
  if (title) title.textContent = 'Select a Metric';
  const valEl = document.getElementById('detail-value');
  if (valEl) valEl.textContent = '–';
  const pctEl = document.getElementById('detail-percentile');
  if (pctEl) pctEl.textContent = '–';
  const interpEl = document.getElementById('detail-interp');
  if (interpEl) interpEl.innerHTML = '–';
  const dirEl = document.getElementById('detail-direction');
  if (dirEl) dirEl.textContent = '–';
  const fill = document.getElementById('percentile-fill');
  if (fill) fill.style.width = '0%';
  highlightMetricSelection();
}

function showBoxplotForMetric(metricKey) {
  const conservation = SUMMARY.conservation || {};
  const boxplots = SUMMARY.boxplots || {};
  
  const metricInfo = conservation[metricKey];
  const boxplotData = boxplots[metricKey];
  
  if (!metricInfo || !boxplotData) {
    document.getElementById('boxplotContainer').innerHTML = '<div class="boxplot-hint">Data not available for this metric</div>';
    return;
  }
  
  activeMetricKey = metricKey;
  highlightMetricSelection();
  
  document.getElementById('boxplotTitle').textContent = metricInfo.label || metricKey;
  document.getElementById('metricDetails').style.display = 'block';
  document.getElementById('detail-value').textContent = typeof metricInfo.value === 'number' ? metricInfo.value.toFixed(4) : '–';
  const pctVal = typeof metricInfo.percentile === 'number' ? metricInfo.percentile : null;
  document.getElementById('detail-percentile').textContent = pctVal != null ? `${pctVal.toFixed(1)}%` : '–';
  document.getElementById('percentile-fill').style.width = pctVal != null ? `${pctVal}%` : '0%';
  const dirText = metricInfo.direction_hint || (metricInfo.higher_is_more_conserved ? 'Higher values = more conserved' : 'Lower values = more conserved');
  const directionEl = document.getElementById('detail-direction');
  if (directionEl) directionEl.textContent = dirText;
  
  let interp = '';
  if (metricInfo.percentile >= 75) interp = '<span class="cons-high">Highly conserved</span> (top 25%)';
  else if (metricInfo.percentile >= 50) interp = '<span class="cons-medium">Moderately conserved</span>';
  else if (metricInfo.percentile >= 25) interp = '<span class="cons-medium">Less conserved than average</span>';
  else interp = '<span class="cons-low">Highly divergent</span> (bottom 25%)';
  document.getElementById('detail-interp').innerHTML = interp;
  
  drawBoxplot(metricInfo, boxplotData);
}

function drawBoxplot(metricInfo, boxplotData) {
  const container = document.getElementById('boxplotContainer');
  container.innerHTML = '<canvas id="boxplotCanvas" style="width:100%;height:180px;"></canvas>';
  
  const canvas = document.getElementById('boxplotCanvas');
  if (!canvas || typeof Chart === 'undefined') {
    container.innerHTML = '<div class="boxplot-hint">Interactive chart requires Chart.js. Metric percentiles are still listed below.</div>';
    boxplotChart = null;
    return;
  }
  const ctx = canvas.getContext('2d');
  const {q1, median, q3, whisker_low, whisker_high, pair_value} = boxplotData;
  
  if (boxplotChart) boxplotChart.destroy();
  
  boxplotChart = new Chart(ctx, {
    type: 'bar',
    data: {
      labels: ['Distribution'],
      datasets: [
        { label: 'Lower', data: [q1 - whisker_low], backgroundColor: 'rgba(200,200,200,0.3)', barPercentage: 0.5 },
        { label: 'Q1-Med', data: [median - q1], backgroundColor: 'rgba(102, 126, 234, 0.4)', barPercentage: 0.5 },
        { label: 'Med-Q3', data: [q3 - median], backgroundColor: 'rgba(118, 75, 162, 0.4)', barPercentage: 0.5 },
        { label: 'Upper', data: [whisker_high - q3], backgroundColor: 'rgba(200,200,200,0.3)', barPercentage: 0.5 },
      ]
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      indexAxis: 'y',
      scales: {
        x: { stacked: true, min: whisker_low - (whisker_high - whisker_low) * 0.1, max: whisker_high + (whisker_high - whisker_low) * 0.1, title: { display: true, text: metricInfo.label } },
        y: { stacked: true, display: false }
      },
      plugins: { legend: { display: false }, tooltip: { enabled: false } }
    },
    plugins: [{
      id: 'pairMarker',
      afterDraw: (chart) => {
        if (pair_value == null) return;
        const ctx = chart.ctx;
        const xAxis = chart.scales.x;
        const yAxis = chart.scales.y;
        const x = xAxis.getPixelForValue(pair_value);
        const y = yAxis.getPixelForValue(0);
        
        ctx.save();
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.fillStyle = '#ef5350';
        ctx.fill();
        ctx.strokeStyle = '#c62828';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = '#333';
        ctx.font = 'bold 11px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('This pair', x, y - 16);
        ctx.font = '10px sans-serif';
        ctx.fillText(pair_value.toFixed(3), x, y + 22);
        ctx.restore();
        
        const medX = xAxis.getPixelForValue(median);
        ctx.save();
        ctx.strokeStyle = '#333';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(medX, y - 18);
        ctx.lineTo(medX, y + 18);
        ctx.stroke();
        ctx.restore();
      }
    }]
  });
}

/* ----------------- Disable unwanted external calls ----------------- *//* ----------------- Disable unwanted external calls ----------------- */
(function(){
  const blockHosts = ['molstarvolseg.ncbr.muni.cz'];
  const _fetch = window.fetch ? window.fetch.bind(window) : null;
  if (_fetch) {
    window.fetch = (input, init) => {
      try {
        const url = (typeof input === 'string') ? input : (input && input.url);
        if (url && blockHosts.some(h => url.includes(h))) {
          return Promise.resolve(new Response(JSON.stringify({ items: [] }), {
            status: 200, headers: { 'Content-Type': 'application/json' }
          }));
        }
      } catch(e) {}
      return _fetch(input, init);
    };
  }
})();

/* ----------------- Mol* wiring (main viewer) ----------------- */
let viewer = null, plugin = null, structureReady = false;
const chainIdA = 'A', chainIdB = 'B';

async function initMolstar(){
  if (viewer) return;
  const opts = {
    layoutIsExpanded:false,
    layoutShowControls:true,
    layoutShowSequence:false,
    layoutShowLog:false,
    layoutShowLeftPanel:false,
    viewportShowExpand:false,
    volumeStreamingServer: ''
  };
  const v = await molstar.Viewer.create('viewer', opts);
  viewer = v;
  plugin = v.plugin;
  window.viewer = viewer;
  window.molstar = molstar;
  window.plugin = plugin;
}

async function loadPDBfromBase64(b64){
  await initMolstar();
  try { await plugin.clear(); } catch(e) {}

  const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
  const blob = new Blob([bytes], {type:"chemical/x-pdb"});
  const url = URL.createObjectURL(blob);

  try {
    await viewer.loadStructureFromUrl(url, 'pdb');
    structureReady = true;
  } catch(e) {
    console.error('Failed to load structure:', e);
    structureReady = false;
  }

  try { await viewer.resetCamera(); } catch(e){ plugin.canvas3d?.requestCameraReset(); }
  URL.revokeObjectURL(url);
}

/* ----------------- Selection + tracks + tables ----------------- */

const selection = new Map();
const trackRefs = {};
const domByUidA = {};
const domByUidB = {};

function selectionKey(chain, uid) {
  return `${chain}:${uid}`;
}

function getAllSelections() {
  return Array.from(selection.values());
}

function sanitizeRects(arr, alnLen){
  if (!Array.isArray(arr)) return [];
  const out=[];
  for (const r of arr){
    let s = Number(r.start ?? r.x ?? r.begin ?? r.from ?? 1);
    let e = Number(r.end   ?? r.to ?? r.stop  ?? r.finish ?? s);
    if (!Number.isFinite(s) || !Number.isFinite(e)) continue;
    s = Math.max(1, Math.min(alnLen, Math.floor(s)));
    e = Math.max(1, Math.min(alnLen, Math.ceil(e)));
    if (e < s) { const t = s; s = e; e = t; }
    if (e < s || e - s < 0) continue;
    const base = { x:s, start:s, begin:s };
    const color = r.color || '#999999';
    const opacity = ('opacity' in r) ? r.opacity : 1.0;
    const id = r.id;
    const label = r.label || r.name || r.type;
    out.push({ ...base, end:e, to:e, color, opacity, id, label });
  }
  return out;
}

function renderTrackSelections() {
  const sel = getAllSelections();
  const hasSel = sel.length > 0;

  const selIdsA = new Set(sel.filter(s => s.chain === chainIdA).map(s => s.id));
  const selIdsB = new Set(sel.filter(s => s.chain === chainIdB).map(s => s.id));
  const colorById = {};
  sel.forEach(s => { colorById[s.id] = s.color; });

  Object.entries(trackRefs).forEach(([name, track]) => {
    if (!track || !track._originalData) return;
    const isA = name.endsWith('A');
    const localSel = isA ? selIdsA : selIdsB;

    const newData = track._originalData.map(item => {
      const id = item.id;
      const isSelected = id && localSel.has(id);
      const baseColor = item.color || '#999999';
      return {
        ...item,
        color: isSelected ? (colorById[id] || baseColor) : baseColor,
        opacity: hasSel ? (isSelected ? 1.0 : 0.25) : 1.0
      };
    });
    track.data = newData;
  });
}

function renderTableSelections() {
  const sel = getAllSelections();
  const selKeys = new Set(sel.map(s => selectionKey(s.chain, s.id)));

  document.querySelectorAll('table#domA tbody tr, table#domB tbody tr').forEach(tr => {
    const uid = tr.getAttribute('data-uid');
    const chain = tr.getAttribute('data-chain');
    const key = selectionKey(chain, uid);
    const checked = selKeys.has(key);
    const cb = tr.querySelector('input[type="checkbox"]');
    if (cb) cb.checked = checked;
    tr.classList.toggle('selected', checked);
  });
}

let viewerLocked = false;
let pendingHighlightLoci = null;

function setViewerLocked(locked) {
  viewerLocked = locked;
  const btn = document.getElementById('lockViewer');
  if (btn) {
    btn.textContent = locked ? 'Unlock Hover' : 'Lock Hover';
    btn.style.background = locked ? '#ffeb3b' : '#fff';
  }
  if (!locked) pendingHighlightLoci = null;
}

function toggleViewerLock() {
  setViewerLocked(!viewerLocked);
}

/* Apply Molstar highlighting for MAIN VIEWER - DUAL COLOR: green for A (select), pink for B (highlight) */
async function applyMolstarSelection() {
  try {
    if (!plugin || !structureReady) return;
    
    // Clear previous selections and highlights
    try {
      plugin.managers.interactivity.lociSelects.deselectAll();
    } catch(e) {}
    try {
      plugin.managers.interactivity.lociHighlights.clearHighlights();
    } catch(e) {}

    const selections = getAllSelections();
    if (selections.length === 0) {
      pendingHighlightLoci = null;
      return;
    }

    const hierarchy = plugin.managers.structure.hierarchy.current;
    if (!hierarchy?.structures?.length) return;

    const structure = hierarchy.structures[0];
    const structureData = structure.cell?.obj?.data;
    if (!structureData) return;

    const units = structureData.units || [];
    if (!units.length) return;

    console.log(`Main viewer: Structure has ${units.length} units (polymers)`);

    // Each unit represents a separate polymer
    // Unit 0 = Polymer 1 = Chain A
    // Unit 1 = Polymer 2 = Chain B
    // CRITICAL: Each unit has its own elements array, and indices in the loci must be 
    // indices INTO unit.elements, not global atom indices!
    
    const chainInfo = {}; // chainId -> { unit, unitIndex, ... }
    
    for (let unitIdx = 0; unitIdx < units.length; unitIdx++) {
      const unit = units[unitIdx];
      try {
        const model = unit.model;
        if (!model) continue;
        
        const chains = model.atomicHierarchy?.chains;
        const chainAtomSegments = model.atomicHierarchy?.chainAtomSegments;
        const residueAtomSegments = model.atomicHierarchy?.residueAtomSegments;
        
        if (!chains || !chainAtomSegments || !residueAtomSegments) continue;
        
        // Get the elements (atom indices) that this unit contains
        const unitElements = unit.elements;
        if (!unitElements || unitElements.length === 0) continue;
        
        // Find which chain the first atom of this unit belongs to
        const firstAtomIdx = unitElements[0];
        const chainOffsets = chainAtomSegments.offsets;
        
        let unitChainId = null;
        for (let ci = 0; ci < chainOffsets.length - 1; ci++) {
          if (firstAtomIdx >= chainOffsets[ci] && firstAtomIdx < chainOffsets[ci + 1]) {
            unitChainId = chains.label_asym_id.value(ci);
            break;
          }
        }
        
        if (!unitChainId) {
          console.warn(`Unit ${unitIdx}: could not determine chain ID`);
          continue;
        }
        
        // Build a mapping from protein residue number (1-based) to local atom indices
        const resOffsets = residueAtomSegments.offsets;
        const unitResidueToLocalAtoms = new Map();
        
        // Determine the first residue in the chain (to compute 1-based protein residue)
        let minGlobalResIdx = Infinity;
        
        // First pass: find all global residue indices in this unit
        for (let localIdx = 0; localIdx < unitElements.length; localIdx++) {
          const globalAtomIdx = unitElements[localIdx];
          for (let ri = 0; ri < resOffsets.length - 1; ri++) {
            if (globalAtomIdx >= resOffsets[ri] && globalAtomIdx < resOffsets[ri + 1]) {
              if (ri < minGlobalResIdx) minGlobalResIdx = ri;
              break;
            }
          }
        }
        
        // Second pass: for each atom, map to protein residue and collect local indices
        for (let localIdx = 0; localIdx < unitElements.length; localIdx++) {
          const globalAtomIdx = unitElements[localIdx];
          for (let ri = 0; ri < resOffsets.length - 1; ri++) {
            if (globalAtomIdx >= resOffsets[ri] && globalAtomIdx < resOffsets[ri + 1]) {
              const proteinRes = ri - minGlobalResIdx + 1;
              if (!unitResidueToLocalAtoms.has(proteinRes)) {
                unitResidueToLocalAtoms.set(proteinRes, []);
              }
              unitResidueToLocalAtoms.get(proteinRes).push(localIdx);
              break;
            }
          }
        }
        
        const residueCount = unitResidueToLocalAtoms.size;
        console.log(`Unit ${unitIdx}: chain ${unitChainId}, ${unitElements.length} atoms, ${residueCount} residues`);
        
        chainInfo[unitChainId] = {
          unit: unit,
          unitIndex: unitIdx,
          residueCount: residueCount,
          unitResidueToLocalAtoms: unitResidueToLocalAtoms
        };
        
      } catch(e) {
        console.warn(`Error analyzing unit ${unitIdx}:`, e);
      }
    }

    // Fallback if detection failed
    if (Object.keys(chainInfo).length === 0) {
      console.warn('Chain detection failed, using simple unit index fallback');
      for (let unitIdx = 0; unitIdx < Math.min(2, units.length); unitIdx++) {
        const chainId = unitIdx === 0 ? 'A' : 'B';
        const unit = units[unitIdx];
        const unitElements = unit.elements;
        if (!unitElements) continue;
        
        const unitResidueToLocalAtoms = new Map();
        const atomsPerResidue = 8;
        let proteinRes = 1;
        for (let i = 0; i < unitElements.length; i += atomsPerResidue) {
          const localAtoms = [];
          for (let j = i; j < Math.min(i + atomsPerResidue, unitElements.length); j++) {
            localAtoms.push(j);
          }
          unitResidueToLocalAtoms.set(proteinRes, localAtoms);
          proteinRes++;
        }
        
        chainInfo[chainId] = {
          unit: unit,
          unitIndex: unitIdx,
          residueCount: unitResidueToLocalAtoms.size,
          unitResidueToLocalAtoms: unitResidueToLocalAtoms
        };
      }
    }

    // Separate selections by chain for dual-color highlighting
    const elementsChainA = [];
    const elementsChainB = [];
    
    for (const sel of selections) {
      try {
        const targetChain = sel.chain; // 'A' or 'B'
        const info = chainInfo[targetChain];
        
        if (!info) {
          console.warn(`No chain info found for chain ${targetChain}`);
          continue;
        }

        const { unit, unitIndex, unitResidueToLocalAtoms } = info;
        
        const startProteinRes = sel.start; // 1-based
        const endProteinRes = sel.end;     // 1-based
        
        console.log(`Selection "${sel.name}" chain ${targetChain}: protein res ${startProteinRes}-${endProteinRes}`);
        
        const localAtomIndices = [];
        
        for (let proteinRes = startProteinRes; proteinRes <= endProteinRes; proteinRes++) {
          const localAtoms = unitResidueToLocalAtoms.get(proteinRes);
          if (localAtoms) {
            localAtomIndices.push(...localAtoms);
          }
        }

        if (localAtomIndices.length > 0) {
          console.log(`  -> ${localAtomIndices.length} LOCAL atoms selected for unit ${unitIndex} (chain ${targetChain})`);
          
          localAtomIndices.sort((a, b) => a - b);
          
          if (targetChain === 'A') {
            elementsChainA.push({ unit, indices: localAtomIndices });
          } else {
            elementsChainB.push({ unit, indices: localAtomIndices });
          }
        } else {
          console.warn(`  -> No atoms found for selection`);
        }
      } catch (e) {
        console.warn(`Failed to process selection ${sel.name}:`, e);
      }
    }
    
    // Apply chain A selections using lociSelects (GREEN color)
    if (elementsChainA.length > 0) {
      const lociA = {
        kind: 'element-loci',
        structure: structureData,
        elements: elementsChainA
      };
      try {
        plugin.managers.interactivity.lociSelects.select({ loci: lociA });
        console.log(`Applied SELECT (green) for chain A with ${elementsChainA.length} element groups`);
      } catch (e) {
        console.warn('Failed to apply chain A selection:', e);
      }
    }
    
    // Apply chain B selections using lociHighlights (PINK color)
    if (elementsChainB.length > 0) {
      const lociB = {
        kind: 'element-loci',
        structure: structureData,
        elements: elementsChainB
      };
      
      pendingHighlightLoci = lociB;
      
      try {
        plugin.managers.interactivity.lociHighlights.highlight({ loci: lociB });
        console.log(`Applied HIGHLIGHT (pink) for chain B with ${elementsChainB.length} element groups`);
      } catch (e) {
        console.warn('Failed to apply chain B highlight:', e);
      }
    } else {
      pendingHighlightLoci = null;
    }
  } catch (e) {
    console.error('applyMolstarSelection failed:', e);
  }
}

/* Re-apply the chain B highlight (called when hover would normally clear it) */
function reapplyChainBHighlight() {
  if (pendingHighlightLoci && viewerLocked) {
    try {
      plugin.managers.interactivity.lociHighlights.highlight({ loci: pendingHighlightLoci });
    } catch(e) {}
  }
}

/* Setup hover interception to maintain highlights when locked */
function setupHoverInterception() {
  if (!plugin?.canvas3d?.interaction?.hover) {
    console.warn('Cannot setup hover interception - interaction.hover not available');
    return;
  }
  
  try {
    plugin.canvas3d.interaction.hover.subscribe((e) => {
      if (viewerLocked && pendingHighlightLoci) {
        setTimeout(() => {
          reapplyChainBHighlight();
        }, 10);
      }
    });
    console.log('Hover interception setup complete');
  } catch(e) {
    console.warn('Failed to setup hover interception:', e);
  }
}

async function initializeHighlightColors() {
  try {
    if (plugin?.canvas3d?.setProps) {
      await plugin.canvas3d.setProps({
        marking: {
          selectColor: { r: 0.26, g: 0.63, b: 0.28 },
          highlightColor: { r: 0.91, g: 0.12, b: 0.39 }
        }
      });
      return true;
    }
  } catch(e) {}
  return false;
}

window.toggleViewerLock = toggleViewerLock;
window.setViewerLocked = setViewerLocked;

/* =============================================================================
   PDBe VIEWER - v6 with simplified chain selection
   ============================================================================= */

let pdbeViewer = null;
let pdbePlugin = null;
let pdbeStructureReady = false;
let currentPdbeEntry = null;
let currentPdbeIndex = -1;

async function initPdbeMolstar() {
  if (pdbeViewer) return;
  const container = document.getElementById('pdbeViewer');
  if (!container) {
    console.error('PDBe viewer container not found');
    return;
  }
  
  try {
    const v = await molstar.Viewer.create('pdbeViewer', {
      layoutIsExpanded: false,
      layoutShowControls: true,
      layoutShowSequence: false,
      layoutShowLog: false,
      layoutShowLeftPanel: false,
      viewportShowExpand: true,
      volumeStreamingServer: ''
    });
    pdbeViewer = v;
    pdbePlugin = v.plugin;
    
    try {
      await pdbePlugin.canvas3d.setProps({
        marking: {
          selectColor: { r: 0.26, g: 0.63, b: 0.28 },
          highlightColor: { r: 0.91, g: 0.12, b: 0.39 }
        }
      });
    } catch(e) {
      console.warn('Could not set PDBe highlight colors:', e);
    }
    
    console.log('PDBe Molstar viewer initialized');
  } catch(e) {
    console.error('Failed to initialize PDBe viewer:', e);
  }
}

async function applyGreyColoring() {
  if (!pdbePlugin || !pdbeStructureReady) return;
  
  try {
    const structures = pdbePlugin.managers.structure.hierarchy.current.structures;
    if (!structures || structures.length === 0) return;
    
    for (const struct of structures) {
      const components = struct.components || [];
      for (const comp of components) {
        if (comp.representations) {
          for (const repr of comp.representations) {
            try {
              const update = pdbePlugin.state.data.build().to(repr.cell)
                .update(old => {
                  return {
                    ...old,
                    colorTheme: {
                      name: 'uniform',
                      params: { value: 0xaaaaaa }
                    }
                  };
                });
              await update.commit();
            } catch(e) {}
          }
        }
      }
    }
    console.log('Applied grey coloring to structure');
  } catch(e) {
    console.warn('Could not apply grey coloring:', e);
  }
}

async function loadPdbeStructureFromBase64(b64, format = 'pdb') {
  await initPdbeMolstar();
  if (!pdbeViewer || !pdbePlugin) {
    console.error('PDBe viewer not available');
    return false;
  }

  try { await pdbePlugin.clear(); } catch (e) {}

  if (!b64 || b64.length < 10) {
    console.warn('No valid base64 data provided');
    pdbeStructureReady = false;
    return false;
  }

  try {
    const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
    const mimeType = format === 'mmcif' || format === 'cif' ? 'chemical/x-mmcif' : 'chemical/x-pdb';
    const blob = new Blob([bytes], { type: mimeType });
    const url = URL.createObjectURL(blob);

    const molstarFormat = (format === 'mmcif' || format === 'cif') ? 'mmcif' : 'pdb';
    
    await pdbeViewer.loadStructureFromUrl(url, molstarFormat);
    pdbeStructureReady = true;
    
    URL.revokeObjectURL(url);
    
    try { 
      await pdbeViewer.resetCamera(); 
    } catch(e) { 
      pdbePlugin.canvas3d?.requestCameraReset(); 
    }
    
    setTimeout(() => applyGreyColoring(), 500);
    
    console.log('PDBe structure loaded successfully');
    return true;
  } catch (e) {
    console.error('Failed to load PDBe structure:', e);
    pdbeStructureReady = false;
    return false;
  }
}

async function fetchAndLoadPdbeStructure(pdbId) {
  await initPdbeMolstar();
  if (!pdbeViewer || !pdbePlugin || !pdbId) return false;

  try { await pdbePlugin.clear(); } catch(e) {}

  const pid = pdbId.toLowerCase();
  
  const sources = [
    { url: `https://files.rcsb.org/download/${pid}.pdb`, format: 'pdb' },
    { url: `https://www.ebi.ac.uk/pdbe/entry-files/download/pdb${pid}.ent`, format: 'pdb' },
    { url: `https://files.rcsb.org/download/${pid}.cif`, format: 'mmcif' },
  ];

  for (const src of sources) {
    try {
      console.log(`Trying to fetch from: ${src.url}`);
      await pdbeViewer.loadStructureFromUrl(src.url, src.format);
      pdbeStructureReady = true;
      console.log(`Successfully loaded ${pdbId} from ${src.url}`);
      
      try { await pdbeViewer.resetCamera(); } catch(e) {}
      setTimeout(() => applyGreyColoring(), 500);
      
      return true;
    } catch(e) {
      console.warn(`Failed to load from ${src.url}:`, e.message);
    }
  }
  
  console.error(`Could not load structure ${pdbId} from any source`);
  pdbeStructureReady = false;
  return false;
}

function getTargetChainIds(entry) {
  if (!entry) return new Set();
  
  const chains = entry.chains || entry.chain_id || entry.chainId || '';
  const targetChains = new Set();
  
  if (Array.isArray(chains)) {
    chains.forEach(c => {
      if (c && typeof c === 'string') {
        targetChains.add(c.trim());
      }
    });
  } else if (typeof chains === 'string') {
    chains.split(/[,\s]+/).forEach(c => {
      const trimmed = c.trim();
      if (trimmed) targetChains.add(trimmed);
    });
  }
  
  console.log('Target chain IDs from PDBe entry:', Array.from(targetChains));
  return targetChains;
}

/**
 * Highlight chains by auth_asym_id - simplified version that trusts PDBe data
 * Iterates all units and checks each one's chain assignment
 */
async function highlightProteinChains(entry) {
  if (!pdbePlugin || !pdbeStructureReady || !entry) {
    console.warn('PDBe viewer not ready for highlighting');
    return;
  }

  const targetChains = getTargetChainIds(entry);
  if (targetChains.size === 0) {
    console.warn('No target chains specified');
    updatePdbeLegend('No chains specified for highlighting.');
    return;
  }

  try {
    try {
      pdbePlugin.managers.interactivity.lociSelects.deselectAll();
      pdbePlugin.managers.interactivity.lociHighlights.clearHighlights();
    } catch(e) {}

    const structures = pdbePlugin.managers.structure.hierarchy.current.structures;
    if (!structures || structures.length === 0) {
      console.warn('No structures loaded');
      return;
    }

    const struct = structures[0];
    const structureData = struct.cell?.obj?.data;
    if (!structureData) {
      console.warn('No structure data');
      return;
    }

    // Log structure info for debugging
    console.log('Structure units:', structureData.units?.length);
    
    const units = structureData.units || [];
    const matchingElements = [];
    const matchedChains = new Set();
    const allChainsFound = new Set();

    for (let unitIdx = 0; unitIdx < units.length; unitIdx++) {
      const unit = units[unitIdx];
      try {
        const model = unit.model;
        if (!model) continue;

        const chains = model.atomicHierarchy?.chains;
        const chainAtomSegments = model.atomicHierarchy?.chainAtomSegments;
        
        if (!chains || !chainAtomSegments) continue;

        const unitElements = unit.elements;
        if (!unitElements || !unitElements.length) continue;

        // Get auth_asym_id for this unit by checking its first atom
        const firstAtomIdx = unitElements[0];
        const chainOffsets = chainAtomSegments.offsets;
        
        let unitAuthChainId = null;
        
        for (let ci = 0; ci < chainOffsets.length - 1; ci++) {
          if (firstAtomIdx >= chainOffsets[ci] && firstAtomIdx < chainOffsets[ci + 1]) {
            unitAuthChainId = chains.auth_asym_id?.value(ci);
            allChainsFound.add(unitAuthChainId);
            break;
          }
        }
        
        if (!unitAuthChainId) continue;
        
        // Check if this unit's chain matches our targets
        if (targetChains.has(unitAuthChainId)) {
          console.log(`Unit ${unitIdx}: chain ${unitAuthChainId} matches target`);
          matchedChains.add(unitAuthChainId);
          
          // Add all atoms in this unit
          const indices = [];
          for (let i = 0; i < unitElements.length; i++) {
            indices.push(i);
          }
          matchingElements.push({ unit, indices });
        }
      } catch(e) {
        console.warn(`Error analyzing unit ${unitIdx}:`, e);
      }
    }

    console.log('All chains found in structure:', Array.from(allChainsFound));
    console.log('Matched chains:', Array.from(matchedChains));

    if (matchingElements.length > 0) {
      const loci = {
        kind: 'element-loci',
        structure: structureData,
        elements: matchingElements
      };

      pdbePlugin.managers.interactivity.lociSelects.select({ loci });
      
      console.log(`Highlighted ${matchingElements.length} units for chains: ${Array.from(matchedChains).join(', ')}`);
      updatePdbeLegend(`<strong>Highlighted:</strong> Chain(s) <strong>${Array.from(matchedChains).join(', ')}</strong> shown in <span style="color:#43a047;font-weight:bold">green</span>.`);
    } else {
      console.warn('No matching chains found. Available chains:', Array.from(allChainsFound));
      updatePdbeLegend(`<strong>Note:</strong> Could not find chains ${Array.from(targetChains).join(', ')}. Available: ${Array.from(allChainsFound).join(', ')}`);
    }

  } catch(e) {
    console.error('Error highlighting protein chains:', e);
  }
}

/**
 * Highlight ligands - finds non-polymer residues (HETATM records)
 */
async function highlightLigands() {
  if (!pdbePlugin || !pdbeStructureReady) {
    console.warn('PDBe viewer not ready for highlighting');
    return;
  }

  try {
    try {
      pdbePlugin.managers.interactivity.lociHighlights.clearHighlights();
    } catch(e) {}

    const structures = pdbePlugin.managers.structure.hierarchy.current.structures;
    if (!structures || structures.length === 0) return;

    const struct = structures[0];
    const structureData = struct.cell?.obj?.data;
    if (!structureData) return;

    const units = structureData.units || [];
    const matchingElements = [];
    const ligandNames = new Set();
    
    // Standard amino acids to exclude
    const standardAA = new Set([
      'ALA','ARG','ASN','ASP','CYS','GLN','GLU','GLY','HIS','ILE',
      'LEU','LYS','MET','PHE','PRO','SER','THR','TRP','TYR','VAL',
      'MSE','SEC','PYL'
    ]);
    
    // Nucleotides to exclude (when part of polymer chain)
    const nucleotides = new Set(['A','C','G','U','T','DA','DC','DG','DT','DU']);
    
    // Water to exclude
    const waterNames = new Set(['HOH', 'WAT', 'H2O', 'DOD', 'SOL']);

    for (let unitIdx = 0; unitIdx < units.length; unitIdx++) {
      const unit = units[unitIdx];
      try {
        const model = unit.model;
        if (!model) continue;

        const residues = model.atomicHierarchy?.residues;
        const residueAtomSegments = model.atomicHierarchy?.residueAtomSegments;
        const atoms = model.atomicHierarchy?.atoms;
        
        if (!residues || !residueAtomSegments) continue;

        const unitElements = unit.elements;
        if (!unitElements || !unitElements.length) continue;

        const resOffsets = residueAtomSegments.offsets;
        const ligandAtomIndices = [];
        const seenResidues = new Set();
        
        for (let i = 0; i < unitElements.length; i++) {
          const atomIdx = unitElements[i];
          
          // Find residue for this atom
          for (let ri = 0; ri < resOffsets.length - 1; ri++) {
            if (atomIdx >= resOffsets[ri] && atomIdx < resOffsets[ri + 1]) {
              // Only process each residue once
              if (seenResidues.has(ri)) {
                // But still add the atom index
                const resName = residues.label_comp_id?.value(ri)?.toUpperCase();
                if (resName && !waterNames.has(resName) && !standardAA.has(resName) && 
                    !(nucleotides.has(resName) && resName.length <= 2)) {
                  ligandAtomIndices.push(i);
                }
                break;
              }
              seenResidues.add(ri);
              
              const resName = residues.label_comp_id?.value(ri)?.toUpperCase();
              if (!resName) break;
              
              // Skip water
              if (waterNames.has(resName)) break;
              
              // Skip standard amino acids
              if (standardAA.has(resName)) break;
              
              // Skip nucleotides that are part of polymer (single/double letter codes)
              if (nucleotides.has(resName) && resName.length <= 2) break;
              
              // This is a ligand!
              ligandAtomIndices.push(i);
              ligandNames.add(resName);
              break;
            }
          }
        }
        
        if (ligandAtomIndices.length > 0) {
          matchingElements.push({ unit, indices: ligandAtomIndices });
        }
        
      } catch(e) {
        console.warn(`Error analyzing unit ${unitIdx} for ligands:`, e);
      }
    }

    if (matchingElements.length > 0 && ligandNames.size > 0) {
      const loci = {
        kind: 'element-loci',
        structure: structureData,
        elements: matchingElements
      };

      pdbePlugin.managers.interactivity.lociHighlights.highlight({ loci });
      
      const ligandList = Array.from(ligandNames).join(', ');
      console.log(`Highlighted ligands: ${ligandList}`);
      updatePdbeLegend(`<strong>Highlighted:</strong> Ligands (<strong>${ligandList}</strong>) shown in <span style="color:#e91e63;font-weight:bold">pink</span>.`);
    } else {
      console.warn('No ligands found in structure');
      updatePdbeLegend(`<strong>Note:</strong> No ligands found in this structure.`);
    }

  } catch(e) {
    console.error('Error highlighting ligands:', e);
  }
}

async function clearPdbeHighlights() {
  if (!pdbePlugin) return;
  
  try {
    pdbePlugin.managers.interactivity.lociSelects.deselectAll();
    pdbePlugin.managers.interactivity.lociHighlights.clearHighlights();
    
    updatePdbeLegend(`Complex shown in <strong>grey</strong>. Click buttons to highlight protein of interest (<span style="color:#43a047">green</span>) or ligands (<span style="color:#e91e63">pink</span>).`);
  } catch(e) {
    console.warn('Error clearing highlights:', e);
  }
}

function updatePdbeLegend(html) {
  const legend = document.getElementById('pdbeLegend');
  if (legend) legend.innerHTML = html;
}

async function syncCameraOrientationFromMainViewer() {
  if (!plugin || !pdbePlugin || !structureReady || !pdbeStructureReady) {
    console.warn('Both viewers must be ready to sync camera');
    return;
  }
  
  try {
    const mainCamera = plugin.canvas3d?.camera;
    const pdbeCamera = pdbePlugin.canvas3d?.camera;
    
    if (!mainCamera || !pdbeCamera) {
      console.warn('Camera not available');
      return;
    }
    
    const mainSnapshot = mainCamera.getSnapshot();
    const pdbeSnapshot = pdbeCamera.getSnapshot();
    
    // Calculate main camera's view direction (normalized)
    const mainDir = [
      mainSnapshot.target[0] - mainSnapshot.position[0],
      mainSnapshot.target[1] - mainSnapshot.position[1],
      mainSnapshot.target[2] - mainSnapshot.position[2]
    ];
    const mainDist = Math.sqrt(mainDir[0]**2 + mainDir[1]**2 + mainDir[2]**2);
    if (mainDist > 0) {
      mainDir[0] /= mainDist;
      mainDir[1] /= mainDist;
      mainDir[2] /= mainDist;
    }
    
    // Calculate current PDBe camera distance from target
    const pdbeDir = [
      pdbeSnapshot.target[0] - pdbeSnapshot.position[0],
      pdbeSnapshot.target[1] - pdbeSnapshot.position[1],
      pdbeSnapshot.target[2] - pdbeSnapshot.position[2]
    ];
    const pdbeDist = Math.sqrt(pdbeDir[0]**2 + pdbeDir[1]**2 + pdbeDir[2]**2);
    
    // Apply main camera's direction to PDBe camera, keeping PDBe's distance and target
    const newState = {
      ...pdbeSnapshot,
      up: mainSnapshot.up,
      position: [
        pdbeSnapshot.target[0] - mainDir[0] * pdbeDist,
        pdbeSnapshot.target[1] - mainDir[1] * pdbeDist,
        pdbeSnapshot.target[2] - mainDir[2] * pdbeDist
      ]
    };
    
    await pdbeCamera.setState(newState, 300);
    
    console.log('Camera orientation synced from main viewer');
  } catch(e) {
    console.warn('Could not sync camera orientation:', e);
  }
}

function updatePdbeInfoBox(entry) {
  if (!entry) {
    document.getElementById('pdbePdbId').textContent = '-';
    document.getElementById('pdbeSourceAcc').textContent = '-';
    document.getElementById('pdbeChains').textContent = '-';
    document.getElementById('pdbeCoverage').textContent = '-';
    document.getElementById('pdbeResolution').textContent = '-';
    document.getElementById('pdbeLigands').textContent = '-';
    return;
  }

  const pdbId = (entry.pdb_id || entry.pdbId || '').toUpperCase();
  const sourceAcc = entry.source_acc || entry.sourceAcc || entry.uniprot_acc || '';
  const chains = entry.chains || entry.chain_id || entry.chainId || '';
  const coverage = entry.coverage;
  const resolution = entry.resolution;
  const ligandSummary = entry.ligandSummary || entry.ligand_summary || '';

  document.getElementById('pdbePdbId').textContent = pdbId || '-';
  document.getElementById('pdbeSourceAcc').textContent = sourceAcc || '-';
  document.getElementById('pdbeChains').textContent = 
    Array.isArray(chains) ? chains.join(', ') : (chains || '-');
  document.getElementById('pdbeCoverage').textContent = 
    (typeof coverage === 'number') ? (coverage * 100).toFixed(1) + '%' : '-';
  document.getElementById('pdbeResolution').textContent = 
    (typeof resolution === 'number') ? resolution.toFixed(2) + ' Å' : '-';
  document.getElementById('pdbeLigands').textContent = ligandSummary || 'None reported';
}

async function loadPdbeByIndex(idx) {
  if (typeof idx === 'string') idx = parseInt(idx, 10);
  if (!Number.isFinite(idx) || idx < 0 || idx >= PDBe_COMPLEXES.length) {
    console.warn('Invalid PDBe index:', idx);
    return;
  }

  const entry = PDBe_COMPLEXES[idx];
  if (!entry) return;

  currentPdbeEntry = entry;
  currentPdbeIndex = idx;
  
  updatePdbeInfoBox(entry);
  updatePdbeLegend(`Loading structure...`);

  const b64 = entry.coord_b64 || entry.coordB64 || entry.pdb_b64 || entry.pdbB64 || '';
  const format = entry.coord_format || entry.coordFormat || 'pdb';
  const pdbId = (entry.pdb_id || entry.pdbId || '').toLowerCase();

  let loaded = false;
  
  if (b64 && b64.length > 100) {
    console.log(`Loading PDBe structure ${pdbId} from base64 (format: ${format})`);
    loaded = await loadPdbeStructureFromBase64(b64, format);
  }
  
  if (!loaded && pdbId) {
    console.log(`Fetching PDBe structure ${pdbId} from remote`);
    loaded = await fetchAndLoadPdbeStructure(pdbId);
  }

  if (loaded) {
    updatePdbeLegend(`Complex shown in <strong>grey</strong>. Click buttons to highlight protein of interest (<span style="color:#43a047">green</span>) or ligands (<span style="color:#e91e63">pink</span>).`);
  } else {
    console.error('Failed to load structure for entry:', entry);
    updatePdbeLegend(`<strong>Error:</strong> Failed to load structure.`);
  }
}

function setupPdbeControls() {
  const structSelect = document.getElementById('pdbeStructSelect');
  const highlightProteinBtn = document.getElementById('pdbeHighlightProtein');
  const highlightLigandsBtn = document.getElementById('pdbeHighlightLigands');
  const clearBtn = document.getElementById('pdbeClearHighlight');
  const syncBtn = document.getElementById('pdbeSyncCamera');
  const centerBtn = document.getElementById('pdbeCenter');

  if (!structSelect) return;

  structSelect.innerHTML = '';

  if (!PDBe_COMPLEXES || PDBe_COMPLEXES.length === 0) {
    const opt = document.createElement('option');
    opt.value = '';
    opt.textContent = 'No experimental structures available';
    structSelect.appendChild(opt);
    structSelect.disabled = true;
    if (highlightProteinBtn) highlightProteinBtn.disabled = true;
    if (highlightLigandsBtn) highlightLigandsBtn.disabled = true;
    updatePdbeInfoBox(null);
    return;
  }

  structSelect.disabled = false;
  if (highlightProteinBtn) highlightProteinBtn.disabled = false;
  if (highlightLigandsBtn) highlightLigandsBtn.disabled = false;

  PDBe_COMPLEXES.forEach((entry, idx) => {
    const pdbId = (entry.pdb_id || entry.pdbId || '').toUpperCase();
    const sourceAcc = entry.source_acc || entry.sourceAcc || '';
    const chains = entry.chains || entry.chain_id || '';
    const resolution = entry.resolution;
    const ligandSummary = entry.ligandSummary || entry.ligand_summary || '';

    let label = pdbId;
    if (sourceAcc) label += ` [${sourceAcc}]`;
    if (chains) {
      const chainStr = Array.isArray(chains) ? chains.join(',') : chains;
      label += ` ch:${chainStr}`;
    }
    if (typeof resolution === 'number') {
      label += ` ${resolution.toFixed(1)}Å`;
    }
    if (ligandSummary) {
      const shortLig = ligandSummary.length > 15 ? ligandSummary.slice(0, 15) + '…' : ligandSummary;
      label += ` (${shortLig})`;
    }

    const opt = document.createElement('option');
    opt.value = String(idx);
    opt.textContent = label;
    structSelect.appendChild(opt);
  });

  structSelect.addEventListener('change', async (e) => {
    await loadPdbeByIndex(e.target.value);
  }, { passive: true });

  if (highlightProteinBtn) {
    highlightProteinBtn.addEventListener('click', async () => {
      if (currentPdbeEntry) {
        await highlightProteinChains(currentPdbeEntry);
      }
    }, { passive: true });
  }

  if (highlightLigandsBtn) {
    highlightLigandsBtn.addEventListener('click', async () => {
      await highlightLigands();
    }, { passive: true });
  }

  if (clearBtn) {
    clearBtn.addEventListener('click', async () => {
      await clearPdbeHighlights();
    }, { passive: true });
  }

  if (syncBtn) {
    syncBtn.addEventListener('click', async () => {
      await syncCameraOrientationFromMainViewer();
    }, { passive: true });
  }

  if (centerBtn) {
    centerBtn.addEventListener('click', () => {
      if (pdbeViewer && pdbeStructureReady) {
        try {
          pdbeViewer.resetCamera();
        } catch(e) {
          pdbePlugin?.canvas3d?.requestCameraReset();
        }
      }
    }, { passive: true });
  }

  if (structSelect.options.length > 0) {
    structSelect.selectedIndex = 0;
    loadPdbeByIndex(0);
  }
}

async function renderSelections() {
  renderTrackSelections();
  renderTableSelections();
  await applyMolstarSelection();
}

function toggleFeature(dom, chain) {
  if (!dom || !dom.uid) return;
  const key = selectionKey(chain, dom.uid);
  if (selection.has(key)) {
    selection.delete(key);
  } else {
    const color = (dom.type === 'Cavity') ? '#ff7d45' : '#ffdb13';
    selection.set(key, {
      id: dom.uid,
      chain,
      start: parseInt(dom.start, 10),
      end: parseInt(dom.end, 10),
      color,
      name: dom.label || dom.name || dom.type || 'region'
    });
  }
  renderSelections();
}

function applyAmMode(mode){
  const modes = AM_MODES;
  if (!modes.includes(mode)) mode = modes[0] || 'raw';
  amMode = mode;

  const alnLen = Math.max(1, (DATA.qaln || '').length);

  if (amTrackA) {
    const rectsA = (DATA.amAlignedARectsByMode && DATA.amAlignedARectsByMode[mode]) || [];
    amTrackA.data = sanitizeRects(rectsA, alnLen);
  }
  if (amTrackB) {
    const rectsB = (DATA.amAlignedBRectsByMode && DATA.amAlignedBRectsByMode[mode]) || [];
    amTrackB.data = sanitizeRects(rectsB, alnLen);
  }

  if (damTrack) {
    const dr = (DATA.damAlignedRectsByMode && DATA.damAlignedRectsByMode[mode]) || [];
    damTrack.data = sanitizeRects(dr, alnLen);
  }

  const matAByMode = DATA.amMatrixA_rectsByMode || {};
  const matBByMode = DATA.amMatrixB_rectsByMode || {};
  const matAForMode = matAByMode[mode] || {};
  const matBForMode = matBByMode[mode] || {};

  amMatrixTracksA.forEach(({track, aa}) => {
    const rects = matAForMode[aa] || [];
    track.data = sanitizeRects(rects, alnLen);
  });
  amMatrixTracksB.forEach(({track, aa}) => {
    const rects = matBForMode[aa] || [];
    track.data = sanitizeRects(rects, alnLen);
  });
}

function addRow(tbl, label, el, h){
  const tr=document.createElement('tr');
  const td1=document.createElement('td'); td1.className='rowlbl'; td1.textContent=label;
  const td2=document.createElement('td'); td2.append(el);
  if (h) el.setAttribute('height', String(h));
  tr.append(td1,td2); tbl.append(tr);
  return { row: tr, labelCell: td1, trackCell: td2 };
}

function buildSeq(){
  const mgr = document.getElementById('mgr'); mgr.innerHTML='';
  const tbl = document.createElement('table'); tbl.className='rtab'; mgr.append(tbl);

  const alnLen = Math.max(1, (DATA.qaln||'').length);

  amMatrixTracksA = [];
  amMatrixTracksB = [];

  const nav = document.createElement('nightingale-navigation');
  addRow(tbl, '', nav, 40);

  const seqA = document.createElement('nightingale-sequence');
  addRow(tbl, DATA.g1+' ('+DATA.a1+') aligned', seqA, 28);

  const domA = document.createElement('nightingale-track');
  addRow(tbl, 'Domains '+DATA.g1, domA, 16); trackRefs['domA'] = domA;

  const disorderA = document.createElement('nightingale-track');
  addRow(tbl, 'Disordered '+DATA.g1, disorderA, 16); trackRefs['disorderA'] = disorderA;

  const tedA = document.createElement('nightingale-track');
  addRow(tbl, 'TED '+DATA.g1, tedA, 16); trackRefs['tedA'] = tedA;

  const cavA = document.createElement('nightingale-track');
  addRow(tbl, 'Cavities '+DATA.g1, cavA, 16); trackRefs['cavA'] = cavA;

  const amA = document.createElement('nightingale-track');
  const amARow = addRow(tbl, 'AlphaMissense '+DATA.g1, amA, 18);
  amARow.row.classList.add('am-main-row');
  amARow.labelCell.classList.add('am-main-label');
  amTrackA = amA;

  const amMatrixRowsA = [];
  const toggleA = document.createElement('button');
  toggleA.textContent = '▼';
  toggleA.className = 'am-matrix-toggle';
  amARow.labelCell.appendChild(toggleA);

  AA_ORDER.forEach(aa => {
    const trk = document.createElement('nightingale-track');
    const rowObj = addRow(tbl, aa, trk, 8);
    rowObj.row.style.display = 'none';
    amMatrixRowsA.push(rowObj.row);
    amMatrixTracksA.push({ track: trk, aa });
  });

  const parentA = amARow.row.parentElement;
  amMatrixRowsA.forEach(r => {
    parentA.insertBefore(r, amARow.row);
  });

  toggleA.addEventListener('click', () => {
    const hidden = amMatrixRowsA.length && amMatrixRowsA[0].style.display === 'none';
    amMatrixRowsA.forEach(r => { r.style.display = hidden ? '' : 'none'; });
    toggleA.textContent = hidden ? '▲' : '▼';
  }, { passive:true });

  const dam = document.createElement('nightingale-track');
  const damRow = addRow(tbl, 'ΔAM', dam, 18);
  damRow.row.classList.add('am-main-row');
  damRow.labelCell.classList.add('am-main-label');
  damTrack = dam;

  const amB = document.createElement('nightingale-track');
  const amBRow = addRow(tbl, 'AlphaMissense '+DATA.g2, amB, 18);
  amBRow.row.classList.add('am-main-row');
  amBRow.labelCell.classList.add('am-main-label');
  amTrackB = amB;

  const amMatrixRowsB = [];
  const toggleB = document.createElement('button');
  toggleB.textContent = '▼';
  toggleB.className = 'am-matrix-toggle';
  amBRow.labelCell.appendChild(toggleB);

  AA_ORDER.forEach(aa => {
    const trk = document.createElement('nightingale-track');
    const rowObj = addRow(tbl, aa, trk, 8);
    rowObj.row.style.display = 'none';
    amMatrixRowsB.push(rowObj.row);
    amMatrixTracksB.push({ track: trk, aa });
  });

  toggleB.addEventListener('click', () => {
    const hidden = amMatrixRowsB.length && amMatrixRowsB[0].style.display === 'none';
    amMatrixRowsB.forEach(r => { r.style.display = hidden ? '' : 'none'; });
    toggleB.textContent = hidden ? '▲' : '▼';
  }, { passive:true });

  const seqB = document.createElement('nightingale-sequence');
  addRow(tbl, DATA.g2+' ('+DATA.a2+') aligned', seqB, 28);

  const domB = document.createElement('nightingale-track');
  addRow(tbl, 'Domains '+DATA.g2, domB, 16); trackRefs['domB'] = domB;

  const disorderB = document.createElement('nightingale-track');
  addRow(tbl, 'Disordered '+DATA.g2, disorderB, 16); trackRefs['disorderB'] = disorderB;

  const tedB = document.createElement('nightingale-track');
  addRow(tbl, 'TED '+DATA.g2, tedB, 16); trackRefs['tedB'] = tedB;

  const cavB = document.createElement('nightingale-track');
  addRow(tbl, 'Cavities '+DATA.g2, cavB, 16); trackRefs['cavB'] = cavB;

  requestAnimationFrame(()=>{
    const allTracks = [
      nav, seqA,
      domA, disorderA, tedA, cavA,
      amA, dam, amB,
      seqB,
      domB, disorderB, tedB, cavB
    ];
    amMatrixTracksA.forEach(obj => allTracks.push(obj.track));
    amMatrixTracksB.forEach(obj => allTracks.push(obj.track));

    allTracks.forEach(el => {
      if (!el) return;
      el.length = alnLen;
      el.displaystart = 1;
      el.displayend = alnLen;
    });

    seqA.data = DATA.qaln || '';
    seqB.data = DATA.taln || '';

    amA.setAttribute('shape','rectangle');
    amB.setAttribute('shape','rectangle');
    dam.setAttribute('shape','rectangle');

    [domA, disorderA, tedA, cavA, domB, disorderB, tedB, cavB].forEach(track => {
      track.setAttribute('shape','roundRectangle');
      track.setAttribute('show-label','');
    });

    domA.data       = sanitizeRects(DATA.domA_alnRects||[], alnLen);          domA._originalData = [...domA.data];
    disorderA.data  = sanitizeRects(DATA.disorderA_alnRects||[], alnLen);     disorderA._originalData = [...disorderA.data];
    tedA.data       = sanitizeRects(DATA.tedA_alnRects||[], alnLen);          tedA._originalData = [...tedA.data];
    cavA.data       = sanitizeRects(DATA.cavA_alnRects||[], alnLen);          cavA._originalData = [...cavA.data];

    domB.data       = sanitizeRects(DATA.domB_alnRects||[], alnLen);          domB._originalData = [...domB.data];
    disorderB.data  = sanitizeRects(DATA.disorderB_alnRects||[], alnLen);     disorderB._originalData = [...disorderB.data];
    tedB.data       = sanitizeRects(DATA.tedB_alnRects||[], alnLen);          tedB._originalData = [...tedB.data];
    cavB.data       = sanitizeRects(DATA.cavB_alnRects||[], alnLen);          cavB._originalData = [...cavB.data];

    applyAmMode(amMode);
  });

  function attachDomainClick(track, chain) {
    track.addEventListener('click', (ev)=>{
      const feat = ev?.detail?.feature;
      if (!feat || !feat.id) return;
      const domMap = (chain === chainIdA) ? domByUidA : domByUidB;
      const dom = domMap[feat.id];
      if (!dom) return;
      toggleFeature(dom, chain);
    }, {passive:true});
  }

  attachDomainClick(domA, chainIdA);
  attachDomainClick(disorderA, chainIdA);
  attachDomainClick(tedA, chainIdA);
  attachDomainClick(cavA, chainIdA);
  attachDomainClick(domB, chainIdB);
  attachDomainClick(disorderB, chainIdB);
  attachDomainClick(tedB, chainIdB);
  attachDomainClick(cavB, chainIdB);
}

function setupPdbeCollapse(){
  const btn = document.getElementById('pdbeCollapseBtn');
  const body = document.getElementById('pdbeCardBody');
  const card = document.getElementById('pdbeCard');
  if (!btn || !body) return;
  btn.addEventListener('click', () => {
    const collapsed = body.classList.toggle('collapsed');
    btn.setAttribute('aria-expanded', (!collapsed).toString());
    btn.textContent = collapsed ? 'Expand section' : 'Collapse section';
    if (card) card.classList.toggle('is-collapsed', collapsed);
  }, {passive:true});
}

function fillDomainTables(){
  const tA = document.querySelector('#domA tbody'); tA.innerHTML='';
  const tB = document.querySelector('#domB tbody'); tB.innerHTML='';

  const addRowDom = (tb, d, chain) => {
    const tr=document.createElement('tr');
    tr.className='clickable';
    tr.setAttribute('data-uid', d.uid || '');
    tr.setAttribute('data-chain', chain);

    const tdSel = document.createElement('td');
    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.addEventListener('change', (ev)=>{
      ev.stopPropagation();
      toggleFeature(d, chain);
    }, {passive:true});
    tdSel.append(cb);

    const tdName = document.createElement('td');
    tdName.textContent = d.label || d.name || d.type || '';

    const tdRange = document.createElement('td');
    tdRange.textContent = `${d.start}-${d.end}`;

    const tdCav = document.createElement('td');
    if (d.type === 'Cavity' || d.raw_type === 'Cavity') {
      const ds = d.drug_score || d.drugscore || '';
      const dg = d.druggability || '';
      tdCav.textContent = (ds || dg) ? `${ds || ''} ${dg || ''}`.trim() : '';
    } else {
      tdCav.textContent = '';
    }

    tr.append(tdSel, tdName, tdRange, tdCav);
    tr.addEventListener('click', ()=>{
      toggleFeature(d, chain);
    }, {passive:true});
    tb.append(tr);
  };

  (DATA.domainsA||[]).forEach(d=>addRowDom(tA,d,chainIdA));
  (DATA.domainsB||[]).forEach(d=>addRowDom(tB,d,chainIdB));

  renderTableSelections();
}

async function fillDomPairs(){
  const tb = document.querySelector('#domPairs tbody'); tb.innerHTML='';
  if (!Array.isArray(DATA.domPairs) || !DATA.domPairs.length){
    tb.innerHTML = '<tr><td colspan="5" class="small">No domain sub-alignments computed.</td></tr>';
    return;
  }
  DATA.domPairs.forEach((r)=>{
    const tr=document.createElement('tr'); tr.className='clickable';
    tr.innerHTML = `<td>${r.Aname} ${r.Arng}</td><td>${r.Bname} ${r.Brng}</td><td>${r.fident!=null?r.fident.toFixed(1)+'%':'–'}</td><td>${r.tm!=null?r.tm.toFixed(3):'–'}</td><td>${r.damPct!=null?r.damPct.toFixed(1)+'%':'–'}</td>`;
    tr.addEventListener('click', async ()=>{
      await reloadViewerWith(r.pdb64);
      document.getElementById('tmScore').textContent = (r.tm!=null ? r.tm.toFixed(3) : '–');
      const title = `Domain: ${r.Aname} ${r.Arng} × ${r.Bname} ${r.Brng}`;
      document.getElementById('contextTitle').textContent = title;

      selection.clear();
      const domA = (DATA.domainsA||[]).find(d => (d.label===r.Aname) || (`${d.start}-${d.end}`===r.Arng));
      const domB = (DATA.domainsB||[]).find(d => (d.label===r.Bname) || (`${d.start}-${d.end}`===r.Brng));
      if (domA) selection.set(selectionKey(chainIdA, domA.uid), {
        id: domA.uid, chain: chainIdA,
        start: parseInt(domA.start,10), end: parseInt(domA.end,10),
        color: '#ffdb13', name: domA.label||domA.name
      });
      if (domB) selection.set(selectionKey(chainIdB, domB.uid), {
        id: domB.uid, chain: chainIdB,
        start: parseInt(domB.start,10), end: parseInt(domB.end,10),
        color: '#ff7d45', name: domB.label||domB.name
      });
      await renderSelections();
    }, {passive:true});
    tb.append(tr);
  });
}

async function colorBy(mode){
  console.log('colorBy requested:', mode);
}

async function reloadViewerWith(b64){
  const host = document.getElementById('viewer');
  host.innerHTML = '';
  viewer=null; plugin=null; structureReady=false;
  await initMolstar();
  await loadPDBfromBase64(b64);
}

async function main(){
  console.log('Initializing report viewer...');
  console.log('PDBe complexes count:', PDBe_COMPLEXES.length);
  initSummarySection();
  
  (DATA.domainsA||[]).forEach(d => { if (d.uid) domByUidA[d.uid] = d; });
  (DATA.domainsB||[]).forEach(d => { if (d.uid) domByUidB[d.uid] = d; });

  document.getElementById('tmScore').textContent = (DATA.tm!=null ? DATA.tm.toFixed(3) : '–');
  document.getElementById('contextTitle').textContent = `Full: ${DATA.g1} × ${DATA.g2}`;
  await reloadViewerWith(PDB64_FULL);

  buildSeq();
  fillDomainTables();
  await fillDomPairs();

  setupPdbeCollapse();
  setupPdbeControls();

  document.getElementById('colorBy').addEventListener('change', (e)=>colorBy(e.target.value), {passive:true});
  document.getElementById('center').addEventListener('click', ()=>{ if(structureReady){ plugin.canvas3d?.requestCameraReset(); }}, {passive:true});
  document.getElementById('lockViewer').addEventListener('click', ()=>{ toggleViewerLock(); }, {passive:true});
  document.getElementById('backFull').addEventListener('click', async ()=>{
    selection.clear();
    pendingHighlightLoci = null;
    await reloadViewerWith(PDB64_FULL);
    document.getElementById('tmScore').textContent = (DATA.tm!=null ? DATA.tm.toFixed(3) : '–');
    document.getElementById('contextTitle').textContent = `Full: ${DATA.g1} × ${DATA.g2}`;
    Object.values(trackRefs).forEach(track => {
      if (track && track._originalData) track.data = [...track._originalData];
    });
    await initializeHighlightColors();
    setupHoverInterception();
    await renderSelections();
  }, {passive:true});

  const amModeSel = document.getElementById('amMode');
  if (amModeSel && Array.isArray(AM_MODES) && AM_MODES.length) {
    amModeSel.innerHTML = '';
    AM_MODES.forEach(m => {
      const opt = document.createElement('option');
      opt.value = m;
      if (m === 'raw') opt.textContent = 'Raw';
      else if (m === 'percentile') opt.textContent = 'Percentile (per protein)';
      else if (m === 'minmax') opt.textContent = 'Min-max (per protein)';
      else if (m === 'zscore') opt.textContent = 'Z-score (logistic)';
      else opt.textContent = m;
      amModeSel.appendChild(opt);
    });
    amModeSel.value = amMode;
    amModeSel.addEventListener('change', (e)=>{
      applyAmMode(e.target.value);
    }, {passive:true});
  }
  
  setTimeout(async () => {
    await initializeHighlightColors();
    setupHoverInterception();
  }, 1500);
  
  console.log('Report viewer initialized');
}

document.addEventListener('DOMContentLoaded', main, {passive:true});
</script>
</body>
</html>
